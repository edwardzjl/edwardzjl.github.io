<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Edwardzjl Blog</title>
        <link>https://edwardzjl.github.io/en</link>
        <description>Edwardzjl Blog</description>
        <lastBuildDate>Fri, 09 Aug 2019 00:00:00 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <language>en</language>
        <item>
            <title><![CDATA[<译>JSON格式作为配置文件的缺点]]></title>
            <link>https://edwardzjl.github.io/en/the-downsides-of-json-for-config-files</link>
            <guid>https://edwardzjl.github.io/en/the-downsides-of-json-for-config-files</guid>
            <pubDate>Fri, 09 Aug 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[翻译自这篇文章]]></description>
            <content:encoded><![CDATA[<p>翻译自<a href="https://www.arp242.net/json-config.html" target="_blank" rel="noopener noreferrer" title="The downsides of JSON for config files">这篇文章</a></p>
<p>我最近接触到许多项目将 <code>JSON</code> 用作配置文件。我认为这不是一个好主意。</p>
<p><code>JSON</code> 从设计之初就不是用于做配置文件的，这也不是它擅长的领域。<code>JSON</code> 的目标是 "轻量级数据交换格式", 同时具有 "易于人类读写", "易于代码解析和生成" 的特点。它在对 "人类而言的便利性" 和 "对机器而言的便利性" 之间取得了较好的平衡, 在许多应用场景下都是比 <code>XML</code> 更好的替代方案。</p>
<p>然而，将 <code>JSON</code> 用于其他目的有点类似于说 "嘿，这把锤子非常适合钉钉子！我喜欢它！为什么不用它来拧螺丝！" 当然它不是完全不能用，只是不合适做这样的工作。</p>
<p>目前为止，将 <code>JSON</code> 用作其它用途最大的问题在于不能在 <code>JSON</code> 文件中添加注释。某些特定的 <code>JSON</code> 解析器支持在 <code>JSON</code> 中添加注释，但是绝大部分的解析器都不支持。<code>JSON</code> 的发明者 <code>Douglas Crockford</code> 声称 <code>JSON</code> 最开始是支持注释的，然而由于一些原因，他特意移除了对注释的支持。想要深入研究的朋友可以看<a href="https://vorba.ch/2013/json-comments.html" target="_blank" rel="noopener noreferrer" title="Why are comments not allowed in JSON?">这里</a>。</p>
<p>我们在写配置文件时经常会遇到需要添加注释的场景。例如解释为什么将配置项设置为当前的值，添加一些助记符或是注意事项，对于错误配置的警告，在文件中保存一份基础的 <code>changelog</code>，又或单纯是在debug时需要注释掉一些配置项。</p>
<p>一个可行的解决方法是将原本的数据存储在一个 object 中，在这个 object 中通过两个条目分别存储数据和注释。例如原本的配置文件如下：</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token property" style="color:#36acaa">"config_name"</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"config_value"</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>修改后变成如下形式:</p>
<div class="language-json codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-json codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token property" style="color:#36acaa">"config_name"</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">	  </span><span class="token property" style="color:#36acaa">"actual_data"</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"config_value"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">		</span><span class="token property" style="color:#36acaa">"comment"</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">"a comment"</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre></div></div>
<p>但是在我看来这种方式丑的压批。</p>
<p>还有一些人指出可以通过 commit log 的形式来实现注释 <em>（译者：不清楚他这里指的是不是 git commit log，如果是的话把这个当作注释方式好像十分难用吧？）</em>，但是又有几个人会去细读 commit history？</p>
<p>一些基于 <code>JSON</code> 进行扩展的格式，例如 <code>JSON5</code>，<code>Hjson</code> 和 <code>HOCON</code>，以及一小部分 <code>JSON</code> 解析器添加了对注释的支持。这很实用，但这些都属于 <code>JSON</code> 的变种，因此不在本篇的讨论范围之内。</p>
<p>同时我也发现手工编辑 <code>JSON</code> 的用户体验不是那么友好：你得留意行尾是否要添加逗号，得了解用不用引号对含义的影响，同时 <code>JSON</code> 也不支持字符串内换行。这些特性对于 "轻量级数据交换格式" 而言不是坏事，但是对于编辑配置文件这件事来说却不是那么可爱。总的来说，将 <code>JSON</code> 用作配置文件虽然可行，但并不优雅。</p>
<p>MediaWiki 的新扩展系统促使我写下这篇文章。旧的系统通过 PHP 文件来挂接核心代码，加载所需的依赖项等。新系统通过 JSON 文件实现这些配置。这样的更新损失了 PHP 那种能够巧妙解决与其他插件兼容性的能力。 <em>（这段没看懂）</em></p>
<p>同时它也带来了更多实现复杂度。旧的系统在引入配置文件时仅仅需要一行代码：</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token function" style="color:#d73a49">require</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'plugin/foo/plugin.php'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><br></span></code></pre></div></div>
<p>而新系统却需要对 JSON 文件的内容进行解析。这在提升实现复杂度的同时，也提高了 debug 的难度。
<em>（这段不太赞同，XML 作为配置文件，同样要进行解析，这不是 JSON 的问题。）</em></p>
<p>使用 JSON 文件存储基本元数据是可行的（更容易解析以及在网站上显示），但使用它来描述代码的工作方式对我来说是滥用 DC（Declarative configuration ，声明性配置）。毕竟，这是代码的工作。</p>
<p>许多人问我那到底该用什么(来做配置文件)，这其实是个很复杂的问题，关系到你程序的应用场景、编程语言、库环境甚至一些社交因素（？）。最好的回答可能就是“找到能符合你需求的最简单的方案”。</p>
<p>有一些 JSON 的扩展格式更适合于人类进行编辑，例如 JSON5、Hjson 和 HOCON。这些看起来都是普通JSON的合理升级，尽管我自己没有使用过它们。特别是 JSON5 似乎是一个不错的选择，因为它对 JSON 的改动最少。我不能给出关于这些扩展格式的建议，因为我没有所有的格式进行深入的比较。只是看一眼格式规范并不能发现潜在的缺点（YAML 就是一个很好的例子）。我没有时间或是兴趣对所有替代方案进行全面深入的审查。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="后记">后记<a href="https://edwardzjl.github.io/en/the-downsides-of-json-for-config-files#%E5%90%8E%E8%AE%B0" class="hash-link" aria-label="Direct link to 后记" title="Direct link to 后记">​</a></h2>
<p>这是我第一次做需要发布到网上的比较正式的翻译工作。虽然最早自己在读 paper 的时候因为英语生疏，也会边读边翻译一些，但是毕竟那是翻译给自己看的，只要自己能看懂就行了，也不用追求什么语句通顺之类的。然而要发布出来的文章不一样，至少要保证大多数读者能够看得懂。</p>
<p>整篇翻完回过头看看，还是有很多生硬似机翻的地方，主要原因可能还是自己的表达能力不够。翻译技术文章在我看来是个吃力不讨好的活，翻的再好也不如直接读原文来的清晰。至于为什么要做这样的事情， 我想有时间单独写一篇谈一谈。目前来看，就权当是对于自己表达能力的锻炼吧。</p>]]></content:encoded>
            <category>json</category>
        </item>
        <item>
            <title><![CDATA[系统中状态为 static 的服务]]></title>
            <link>https://edwardzjl.github.io/en/static-service</link>
            <guid>https://edwardzjl.github.io/en/static-service</guid>
            <pubDate>Thu, 04 Jul 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[最近开始接触 Linux 运维的工作，第一件事情就是看看系统中跑了多少服务。]]></description>
            <content:encoded><![CDATA[<p>最近开始接触 Linux 运维的工作，第一件事情就是看看系统中跑了多少服务。</p>
<p>集群用的是 CentOS 7，可以通过 <code>bash systemctl list-unit-files</code> 这个命令查看所有服务，敲下回车后打印出来这么一堆玩应儿：</p>
<p><img decoding="async" loading="lazy" alt="services" src="https://edwardzjl.github.io/en/assets/images/services-1f32b5744640cabbd42f360a89b1bffb.png" title="services" width="454" height="474" class="img_ev3q"></p>
<p>service 的 <code>disabled</code> 和 <code>enabled</code> 状态都好理解，<code>static</code> 是个啥？在<a href="https://bbs.archlinux.org/viewtopic.php?id=147964" target="_blank" rel="noopener noreferrer" title="systemd 'static' unit file state">不存在的网站</a>上一顿查找，找到如下这番解释：</p>
<blockquote>
<p>"static" means "enabled because something else wants it". Think by analogy to pacman's package install reasons:</p>
<ul>
<li>enabled :: explicitly installed</li>
<li>static :: installed as dependency</li>
<li>disabled :: not installed</li>
</ul>
</blockquote>
<p>意思是，状态为 <code>static</code> 的服务，是作为别的服务的依赖而存在。</p>]]></content:encoded>
            <category>linux</category>
        </item>
        <item>
            <title><![CDATA[<译> javax.persistence.Id 和 org.springframework.data.annotation.Id 的区别]]></title>
            <link>https://edwardzjl.github.io/en/difference-between-javax.persistence.id-and-org.springframework.data.annotation.id</link>
            <guid>https://edwardzjl.github.io/en/difference-between-javax.persistence.id-and-org.springframework.data.annotation.id</guid>
            <pubDate>Thu, 27 Jun 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[org.springframework.data.annotation.Id]]></description>
            <content:encoded><![CDATA[<h2 class="anchor anchorWithStickyNavbar_LWe7" id="orgspringframeworkdataannotationid">org.springframework.data.annotation.Id<a href="https://edwardzjl.github.io/en/difference-between-javax.persistence.id-and-org.springframework.data.annotation.id#orgspringframeworkdataannotationid" class="hash-link" aria-label="Direct link to org.springframework.data.annotation.Id" title="Direct link to org.springframework.data.annotation.Id">​</a></h2>
<p><code>org.springframework.data.annotation.Id</code> 是 Spring 定义的 annotation，用来支持 "没有像 JPA 那样的持久化 API" 的非关系型数据库或是框架的持久化，因此它常被用于其它 spring-data 项目，例如 spring-data-mongodb 和 spring-data-solr 等。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="javaxpersistenceid">javax.persistence.Id<a href="https://edwardzjl.github.io/en/difference-between-javax.persistence.id-and-org.springframework.data.annotation.id#javaxpersistenceid" class="hash-link" aria-label="Direct link to javax.persistence.Id" title="Direct link to javax.persistence.Id">​</a></h2>
<p><code>javax.persistence.Id</code> 是由 JPA 定义的 annotation，JPA 仅适用于关系数据的管理。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="ref">Ref<a href="https://edwardzjl.github.io/en/difference-between-javax.persistence.id-and-org.springframework.data.annotation.id#ref" class="hash-link" aria-label="Direct link to Ref" title="Direct link to Ref">​</a></h2>
<ul>
<li><a href="https://stackoverflow.com/questions/39643960/whats-the-difference-between-javax-persistence-id-and-org-springframework-data" target="_blank" rel="noopener noreferrer">whats-the-difference-between-javax-persistence-id-and-org-springframework-data</a></li>
</ul>]]></content:encoded>
            <category>spring</category>
            <category>java</category>
        </item>
        <item>
            <title><![CDATA[Install postgres on OSX]]></title>
            <link>https://edwardzjl.github.io/en/install-postgres-on-osx</link>
            <guid>https://edwardzjl.github.io/en/install-postgres-on-osx</guid>
            <pubDate>Sat, 13 Apr 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[If you installed Postgres from homebrew, the default user postgres isn't automatically created, you need to run following command in your terminal:]]></description>
            <content:encoded><![CDATA[<p>If you installed Postgres from homebrew, the default user <code>postgres</code> isn't automatically created, you need to run following command in your terminal:</p>
<div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">/Applications/Postgres.app/Contents/Versions/9.*/bin/createuser -s postgres</span><br></span></code></pre></div></div>]]></content:encoded>
            <category>postgres</category>
            <category>osx</category>
        </item>
        <item>
            <title><![CDATA[Ubuntu / CentOS 编译安装带剪贴板支持的 Vim]]></title>
            <link>https://edwardzjl.github.io/en/config-vim-8-clipboard</link>
            <guid>https://edwardzjl.github.io/en/config-vim-8-clipboard</guid>
            <pubDate>Thu, 14 Mar 2019 00:00:00 GMT</pubDate>
            <description><![CDATA[通过 Ubuntu 或 CentOS 系统自带的软件源安装 Vim，往往只能得到较旧的版本（通常是 7.4.x）。而从 Vim 8.0 开始，官网推荐的安装方式是通过 Git 克隆源码自行编译。]]></description>
            <content:encoded><![CDATA[<p>通过 Ubuntu 或 CentOS 系统自带的软件源安装 Vim，往往只能得到较旧的版本（通常是 7.4.x）。而从 Vim 8.0 开始，官网推荐的安装方式是通过 Git 克隆源码自行编译。</p>
<p>不过需要注意，<strong>默认编译出来的 Vim 并不包含剪贴板支持（clipboard support）</strong>，因此无法与系统剪贴板交互（例如复制粘贴到其他程序）。</p>
<p>要在编译时启用剪贴板支持，至少需要两个依赖包：</p>
<ul>
<li><code>libx11-dev</code>：提供 Xorg 的头文件（xorg header files）</li>
<li><code>dbus-x11</code>：提供 X11 的 D-Bus 支持</li>
</ul>
<p>你可以在 <a href="https://packages.ubuntu.com/" target="_blank" rel="noopener noreferrer">https://packages.ubuntu.com</a> 搜索具体的依赖项位置，最终确认这两个包就是我们所需的。</p>
<p>安装依赖并编译 Vim 的完整流程如下：</p>
<div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">sudo apt-get install libx11-dev dbus-x11</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">git clone https://github.com/vim/vim.git</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">cd vim</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">./configure --with-features=huge --enable-gui=auto --enable-cscope --prefix=/usr/local</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">make</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">sudo make install</span><br></span></code></pre></div></div>
<blockquote>
<p>其中 <code>--with-features=huge</code> 启用几乎所有功能，<code>--enable-gui=auto</code> 可选启用 GUI 模式（如 gvim），<code>--enable-cscope</code> 则用于增强代码导航功能。</p>
</blockquote>
<p>安装完成后，你可以使用 <code>vim --version</code> 检查是否启用了 <code>+clipboard</code>，确认剪贴板支持是否生效。</p>]]></content:encoded>
            <category>vim</category>
        </item>
    </channel>
</rss>